---
layout: page
title: Lesson 7
page_order: 6
parent: Lessons
grand_parent: Overview - iOS
description: A Glimpse into Modern Cocoa Touch APIs
---

# A Glimpse into Modern Cocoa Touch APIs

{: .no_toc }
*Michael Lin*

## Table of Contents
{: .no_toc .text-delta }

1. TOC
{:toc}

# New UIButton APIs

## UIButton.Configuration (iOS 15)

## Handler Function Using UIAction (iOS 14)

See [redesigned simple roll call](/calhacks/index/#demo)

# Modern Collection View

## Compositional Layout (iOS 13)

In Lesson 1 we talked about using `UICollectionViewFlowLayout`, a subclass of `UICollectionViewLayout`, to create a collection view that displays cells in a line-based fashion.

<img src="https://developer.apple.com/library/archive/documentation/WindowsViews/Conceptual/CollectionViewPGforIOS/Art/flow_horiz_layout_uneven_2x.png"
    alt="Flow layout"
    style="width: 80%; display: block; margin: auto;" />

Today we will introduce another layout class called [`UICollectionViewCompositionalLayout`](https://developer.apple.com/documentation/uikit/uicollectionviewcompositionallayout). It is often used to create complex layout pattern that is difficult to achieved through a simple flow layout. A compositional layout is composed of one or more *sections*. Each section breaks up into *groups*. A group may contain other groups or individual cells which we call *items* in compositional layout.

<div style="display: flex; justify-content: center; align-items: center;">
<img src="/assets/images/appstore-collection-view.jpeg"
    alt="Collection View in iOS"
    style="width: 35%; display: inline-block; margin: auto;" />

<img src="https://docs-assets.developer.apple.com/published/2308306163/rendered2x-1585241228.png"
    alt="Section, groups, and items in collection view layout"
    style="width: 45%; display: inline-block; margin: auto;" />
</div>

Similar to how we would instantiate a flow layout object in the beginning when we create the collection view, we need to construct an `UICollectionViewCompositionalLayout` instance to feed into the collection view initializer. Through the process of constructing the layout object we will specify how the corresponding collection view should layout its sections, groups, and items.

### Item

Items are the smallest unit of layout. It is described by a `layoutSize:` parameter, which specify the size of that item.
It takes an instance of `NSCollectionLayoutSize`, which has only one initializer: `NSCollectionLayoutSize(widthDimension:heightDimension:)`. For each dimension, you will pass in an [`NSCollectionLayoutDimension`](https://developer.apple.com/documentation/uikit/nscollectionlayoutdimension) object. `NSCollectionLayoutDimension` is the core of compositional layout. It allows you to specify dimension size in one of four ways:
- `.absolute(_:)`: An absolute value equal to the `CGFloat` that you pass in.
- `.fractionalWidth(_:)`: A fractional value (0-1) with respect to the width dimension of the enclosing layout object (a group, a section, etc.)
- `.fractionalHeight(_:)`: A fractional value (0-1) with respect to the height dimension of the enclosing layout object (a group, a section, etc.)
- `.estimated(_:)`: An estimated value, meaning it won't stop the inside layout object from grow bigger or smaller.

For example, assuming our enclosing object is a row defined as a group, which takes the full width of the section as well as the screen, a square cell that fits into one fifth of the row space can be defined as follow:
```swift
let itemSize = NSCollectionLayoutSize(widthDimension: .fractionalWidth(1/5),
                                      heightDimension: .fractionalWidth(1/5))
let item = NSCollectionLayoutItem(layoutSize: itemSize)
```

You can further customize it by changing some of its properties

```swift
item.contentInsets = NSDirectionalEdgeInsets(top: 1, leading: 2, 
                                             bottom: 3, trailing: 4)

item.edgeSpacing = NSCollectionLayoutEdgeSpacing(leading: .flexible(40), 
                                                 top: .fixed(10), 
                                                 trailing: .flexible(40), 
                                                 bottom: .fixed(0))
```

Here the [`NSDirectionalEdgeInset`](https://developer.apple.com/documentation/uikit/nsdirectionaledgeinsets) is very similar to `UIEdgeInset` that you've probably seen before, the only difference is that directional edge inset accounts for the text direction of the current language settings. (btw this is also the difference between leading/trailing vs left/right anchors in Auto Layout). The edge spacing however, is a bit more mysterious. Unlike content inset, it specify the outer spacing of the content box. If you are familiar with web design and CSS that sort of stuff, it's like the difference between margin and padding - with a little iOS twist. For each edge in an edge spacing, you can choose between a fixed or a flexible value. The fixed values work just like you would expect, while the flexible values will make the space greater than or equal to the given point value, depending on whether there's extra space.

### Group

Group is the intermediate layer and the backbone of our collection view layout. Since groups can encapsulate items as well as other groups, it can be used to create very complex layers of UI. But let's start with a simple example. Suppose we want to create a row that can fit the items we just defined. To initialize a layout group, we will use the [`NSCollectionLayoutGroup`](https://developer.apple.com/documentation/uikit/nscollectionlayoutgroup?language=occ) class, which comes with two factory methods: [`NSCollectionLayoutGroup.horizontal(layoutSize:subitems:)`](https://developer.apple.com/documentation/uikit/nscollectionlayoutgroup/3213855-horizontal) and [`NSCollectionLayoutGroup.vertical(layoutSize:subitems:)`](https://developer.apple.com/documentation/uikit/nscollectionlayoutgroup/3213860-vertical). Since we are defining rows, we will use the horizontal one (again we are assuming that the section takes the full screen width. However, it doesn't actually matter if it's smaller as everything is defined using fractions).
```swift
let rowGroupSize = NSCollectionLayoutSize(widthDimension: .fractionalWidth(1.0),
                                       heightDimension: .fractionalWidth(1/5))
let rowGroup = NSCollectionLayoutGroup
                .horizontal(layoutSize: rowGroupSize, subitems: [item])
```
The `subitems: [item]` argument defines what's in the group. You can put any items and/or groups in the array. But the actual array of of objects will be automatically extended to fill the space within the group. For instance, if the subitems are `[item1, group2]`, and the group has space for two of them plus an `item1`, the actual objects inside will be `[item1, group2, item1, group2, item1]`

Alternatively, you can use a variant of the two methods: [`NSCollectionLayoutGroup.vertical(layoutSize:subitem:count:)`](https://developer.apple.com/documentation/uikit/nscollectionlayoutgroup/3213859-vertical) or [`NSCollectionLayoutGroup.horizontal(layoutSize:subitem:count:)`](https://developer.apple.com/documentation/uikit/nscollectionlayoutgroup/3213854-horizontal). In this case you can only use one type of subitem (either an item or another group). In addition, the layout will override the child's width or height dimension if necessary to achieve the number of objects you specified for that group. So if instead of saying `layoutSize: rowGroupSize, subitems: [item]` like we did in the previous code snippet, we can write

```swift
let rowGroup = NSCollectionLayoutGroup
                .horizontal(layoutSize: rowGroupSize, subitem: item, count: 6)
```
Even if we define the items width dimension to be of fraction width **1/5**, the actual width would be fractional width **1/6**, because the 1/5 would be overrode by the `count: 6` in `rowGroup`.

Just like items, groups have several properties which you can customize. In addition to the content insets and edge spacing that we mentioned before. Groups allow you to specify the spacing between each of the two objects, and it too can have either a fixed or a flexible value.
```swift
rowGroup.interItemSpacing = .flexible(20)
```

### Section

Finally, we've reached sections. To instantiate a section, you simply need

```swift
let section = NSCollectionLayoutSection(group: group)
```

After you initialize the section, you could define the header, footer, and one of my all time favorite: the orthogonal scrolling behavior. This gives you the ability scroll through the groups in a section orthogonal to the scrolling direction (vertical by default) of your collection view. And this is what Apple did in the App Store app, which enables you to scroll both vertically through the collection view, and horizontally through each section.

```swift
section.orthogonalScrollingBehavior = .groupPaging
```

There's no need to specify the size of the section though. Because the size will determined by auto layout and the scrolling direction of the collection view. For example, if the collection view's scrolling direction is vertical, and the width of the view is set by constraints to be the full width of the screen, our section would have the width of the screen. In the case where there's no orthogonal scrolling, the groups in that section will stack vertically and grow towards the bottom. If there is orthogonal scrolling, the groups will then grow orthogonally towards the trailing edge, which the users will be able to scroll to according to the scrolling behavior.

### Putting it Together

Now that you've learned the basics of compositional layout, we will learn how to put them together into a `UICollectionViewCompositionalLayout` object. For the single-section, 5xN-grid layout that we previously described, you probably only need the [`UICollectionViewCompositionalLayout(section:)`](https://developer.apple.com/documentation/uikit/uicollectionviewcompositionallayout/3199211-init) initializer. But in case you want to have layout that is section-based, Apple has also packed a section provider initializer [`UICollectionViewCompositionalLayout(sectionProvider:)`](https://developer.apple.com/documentation/uikit/uicollectionviewcompositionallayout/3199214-init). The provider is a closure that takes two positional arguments: an integer section index, and a layout environment object that has the current layout container and the trait collection of the app. You can use that to dynamically generate your layout based on section, interface size class, device type, and so on.

You can also provide a [`UICollectionViewCompositionalLayoutConfiguration`](https://developer.apple.com/documentation/uikit/uicollectionviewcompositionallayoutconfiguration) object along with the section or section provider, which specifies property such as scrolling direction, intersectional spacing, etc.

## Diffable Data Source (iOS 13)

Another advancement that Apple made with regard to collection view is the diffable data source. Previously when applying changes to a collection view, we rely on index path to obtain the instance of the cell. But this model isn't very robust. Because as cells are being reused and relocated, index paths are being changed constantly. So it typically leads to a lot of bookkeeping and programing errors.

Diffable data source eliminate those concerns by using a hashable identifier object to identify each cell. Normally this would be the items that you would display in a cell, such as a user or an event. Each object will be associated with a section which we discussed earlier in compositional layout. The only requirement is that the object must implement the [`hashable`](https://developer.apple.com/documentation/swift/hashable) protocol, and the hash must be unique for different objects. Since in most app you would already have a unique identifier for the model objects, this usually wouldn't be an issue. For example, consider the following `Event` struct.

```swift
struct Event {
    let uid: String   
    let name: String
    /* ... */
}
```

To refactor for diffable data source, we simply add the protocol conformance and an updated hash method.

```swift
struct Event: Hashable {
    let uid: String
    let name: String
    /* ... */
    func hash(into hasher: inout Hasher) {
        hasher.combine(uid)
    }
}
```

After this is done, you will configure your data source in the view controller. One of the biggest changes in diffable data source is that it's no longer implemented through protocol, instead, it uses an generic object [`UICollectionViewDiffableDataSource<SectionIdentifierType, ItemIdentifierType>`](https://developer.apple.com/documentation/uikit/uicollectionviewdiffabledatasource). The item identifier would just be the hashable class or struct. For the section identifier, typically it would just be an enumeration type with the possible sections. For example, if we just want one section for our collection view we would write:

```swift
class EventCollectionVC: UIViewController {
    enum Section { case main }
    /* ... */
}
```

Since our data source is now an object, we will need to keep a reference to it so that it doesn't get deallocated and also in case we need it later.

```swift
class EventCollectionVC: UIViewController {
    /* ... */
    var dataSource: UICollectionViewDiffableDataSource<Section, Event>!
}
```

Finally, after all these setups are completed, we will then generate the compositional layout, initialize the collection view, configure the data source, and apply the initial *snapshot* to the data source. [`NSDiffableDataSourceSnapshot`](https://developer.apple.com/documentation/uikit/nsdiffabledatasourcesnapshot) are the foundation of diffable data source. It reflects what you want each section in the collection view to display at that given point. When you apply a snapshot to the data source, the data source automatically performs a diff operation between the incoming snapshot and the current snapshot, and figures out what needs to be changed. 

Diffable data source can be initialized with the [`UICollectionViewDiffableDataSource<SectionIdentifierType, ItemIdentifierType>(collectionView:cellProvider:)`](https://developer.apple.com/documentation/uikit/uicollectionviewdiffabledatasource/3255138-init) initializer. The argument `collectionView:` is just the collection view that you want to use the data source for, and the cell provider is again a closure, which takes three positional arguments: the collection view instance, an index path, and the identifier. The closure returns a `UICollectionViewCell` just like before in the data source protocol.

Following is a simplified example of the workflow.

```swift
class EventCollectionVC: UIViewController {
    enum Section { case main }

    var eventCollectionView: UICollectionView!
    var dataSource: UICollectionViewDiffableDataSource<Section, Event>!
}

extension EventCollectionVC {
    func generateLayout() -> UICollectionViewLayout {
        /* ... */
    }

    func configureCollectionView() {
        eventCollectionView = UICollectionView(frame: view.bounds, 
                                               collectionViewLayout: generateLayout())
        /* customization, cell registration, etc. */
        view.addSubview(eventCollectionView)
    }

    func configureDataSource() {
        dataSource = UICollectionViewDiffableDataSource<Section, Event>(collectionView: eventCollectionView) {
            (collectionView: UICollectionView, indexPath: IndexPath, identifier: Event) -> UICollectionViewCell? in
            /* Initialize and configure a cell */
            return cell
        }
        dataSource.apply(generateSnapshot(), animatingDifferences: false)
    }

    func generateSnapshot() -> NSDiffableDataSourceSnapshot<Section, Event> {
        var snapshot = NSDiffableDataSourceSnapshot<Section, Event>()
        snapshot.appendSection([.main])
        snapshot.appendItems(/* The event objects */)
        return snapshot
    }
}
```
