---
layout: page
title: Lesson 0
page_order: 0
parent: Lessons
grand_parent: Overview
description: None
---

# Introduction to Swift and iOS Development
{: .no_toc }
*by Michael Lin*
## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

# Getting Started

## Install Xcode

If you haven't done it already, go to App Store and install the latest version of Xcode. The entire SDK would be around 30G, but it can get to 40G or even 60G after compiling some larger projects. So you might need to free up some space before doing that.

For the following Swift Tutorial, it might be helpful to try out some of the expressions yourself. In that case, you can use a Swift Playground. It's a place where you can conveniently run your Swift code and it's mainly used as an educational tool. To create a Swift Playground, you will first need to set up and launch Xcode. 
![Xcode Launch Screen](/assets/images/xcode-launch-screen.png "Xcode Launch Screen")
When you are on this screen, go to the top-left menu bar and select **File > New > Playground..** When Xcode asks you to choose a template, double click **Blank**. For the file location, my experience is you can keep it anywhere you like, but if you are using iCloud storage, do **NOT** put any Xcode files or projects in the folder that's using iCloud (generally that would mean Desktop and Documents). Especially when we start using Cocoapods, Xcode might start duplicating files if your local files are replaced with iCloud references.

# The Swift Programming Language

## Constants and Variables

In Swift, you declare a constant with the `let` keyword and variables with the `var` keyword.
``` swift
var foo = ‚ÄúHello‚Äù   /* Variable */
let bar = ‚ÄúWorld‚Äù   /* Constant */
```
You cannot reassign the value of a constant once it's declared.

You can specify the type of a variable or constant using `:`. This also allows you to declare a variable or constant without initializing it. However, it will not be usable until you give it a value (even `nil`).

``` swift
var name: String
name = ‚ÄúOski‚Äù
```

If you do not specify a type, Swift can infer it from the value it was initially assigned to. This is known as **type inference**.

Swift is a **strongly-typed** language. That means you can't reassign the value of a variable or constant to a different type once it's declared.

For naming, always stick to lowerCamelCase for constants and variables.

## Collection Types

Swift provides three primary collection types, known as arrays, sets, and dictionaries, for storing collections of values. Arrays are ordered collections of values. Sets are unordered collections of unique values. Dictionaries are unordered collections of key-value associations.

![Collections in Swift](https://docs.swift.org/swift-book/_images/CollectionTypes_intro_2x.png "Collections in Swift")

### Array

The type of a Swift array is written in full as `Array<Element>`, where Element is the type of values the array is allowed to store. You can also write the type of an array in shorthand form as `[Element]`. Therefore, an array can be declared
like this
```swift
var libraries: [String] = ["Moffitt", "Main Stack", "EAL"]
```
Retrieve or modify a value from the array by using a subscript.
```swift
var firstItem = libraries[0]
libraries[1] = "Music Library"
```
Append a new value by calling the `append(_:)` method
```swift
libraries.append("Engineering Library")
```
Alternatively, append an array of one or more compatible items with the addition assignment operator `+=`
```swift
libraries += ["Law Library", "Bancroft"]
```

### Dictionary

The type of a Swift dictionary is written in full as `Dictionary<Key, Value>`, where Key is the type of value that can be used as a dictionary key, and Value is the type of value that the dictionary stores for those keys. You can also write the type of a dictionary in shorthand form as `[Key: Value]`. Therefore, a dictionary can be declared like this
```swift
var distance: [String: Double] = ["Moffitt": 0.9, "Main Stack": 1.0, "EAL": 1.1]
print("The dictionary contains \(distance.count) items.")
// Prints "The dictionary contains 3 items."
```
Similar to arrays, you can retrieve or modify a value from the dictionary using subscript.
```swift
distance["Main Stack"] = 1.3
distance["Moffitt"]
```
However, there is no `append(_:)` method in dictionary. To add a new value, simply use the subscript.
```swift
distance["Music Library"] = 1.5
```

### Set

The type of a Swift set is written as Set<Element>, where Element is the type that the set is allowed to store. Sets do not have an equivalent shorthand form. A set can be created with an array literal.

```swift
var libraries: Set<String> = ["Moffitt", "Main Stack", "EAL"]
```

You can insert an element by calling the set's `insert(_:)` method. To check whether a set contains a particular item, use the `contains(_:)` method.

## Control Flow

### If Statement

In swift, a basic `if` statement looks like this
``` swift
if condition {
    action
}
```
You can chain multiple `if` statement together using `else if` and `else`
```swift
if condition {
    statements
} else if {
    statements
} else {
    statements
}
```
You can combine multiple predicates using the logical operator `!` `||` `&&`.
For single-expression if statements, you can usually simplify them with the
**ternary operator**
```swift
condition ? expression : expression
```
If the condition is true, the first expression will be executed and its return
value would be the return value of the whole statement. A simple example can
look like this
```swift
var feel: String = temp > 75 : "hot" : "ok" 
```

### For-In Loops

You use the `for-in` loop to iterate over a sequence, such as items in an array, ranges of numbers, or characters in a string.
```swift
let names: [String] = ["Anna", "Alex", "Brian", "Jack"]
for name in names {
    print("Hello, \(name)!")
}
```
You can also use `in` to iterate through a dictionary. That would give you
all of its key-value pairs.
```swift
let numberOfLegs: [String: Int] = ["spider": 8, "ant": 6, "cat": 4]
for (animalName, legCount) in numberOfLegs {
    print("\(animalName)s have \(legCount) legs")
}
```

### While Loops

A `while` loop starts by evaluating a single condition. If the condition is `true`, a set of statements is repeated until the condition becomes `false`.
```swift
while condition {
    statements
}
```

## Functions

Every function is a chunk of code that performs a specific task. It is defined using the keyword `func` followed by the name of the function. Optionally, you can define one or more parameters to be passed in as input. You can also specify the return type using `->`. For example, a simple function declaration can look like this.

```swift
func answer(question: String) -> String { }
```

You would then call the function using its name and parameter, which will return a `String`.

```swift
var answer1: String = answer(question: "Question 1")
```

For each parameter, you can also specify its *label*, and it will be used when you are **calling** the function. This helps to create easier to read function calls like this.

```swift
func answer(for question: String) -> String { }

var answer1: String = answer(for: "Question 1")
```

By default, the *argument labels* are the same as the *parameter names*, and will be used when calling the function like in `answer(question: "Question 1")`. If you want no function label at all during the function call, write an underscore `_` for that parameter.

```swift
func answer(_ question: String) -> String { }

var answer1: String = answer("Question 1")
```

## Classes

If you are new to the OOP (Object-Oriented Programming) model, there are many ways of describing classes. But here is my favorite: Think of it as a blueprint for a house. You can create multiple instances of that house with the same blueprint, but the interior design which is the data is going to be different. Each house operates on its own, but they all share the same structure and behaviors. 

In Swift, classes are declared using the `class` keyword. You define properties and methods to add functionality to your classes using the same syntax you use to define constants, variables, and functions.

```swift
class User {
    var username: String = ""
    var email: String = ""

    func printEmail() {
        print(email)
    }
}
```

A class can *inherit* methods, properties, and other characteristics from another class. When one class inherits from another, the inheriting class is known as a *subclass*, and the class it inherits from is known as its *superclass*.

```swift
class Admin: User {
    managedUsers: [User] = []
}
```

The value assigned with property declarations are the **default values** that will be assigned during class initialization. If no default value is specified, a custom initializer is needed.

```swift
class Admin: User {
    managedUsers: [User]

    init(withManagedUsers users: [User]) {
        self.managedUsers = users
        super.init()
    }
}
```
Members of an class (either a property or a method) can be accessed using the dot notation `.`.
```swift
let user = User()
let user.email = "example@domain.com"
```

## Structs

In Swift, structures and classes have very similar functionalities. Both of them can define properties and methods, conform to protocols, and be extended using an extension (we will talk about the last two in the next lesson).
```swift
struct Event {
    var eventName: String
    var startTime: Date
    var endTime: Date

    // Initializer
}
```

However, there are a few key differences too:
- Classes can inherit from another class and/or conform to one or more protocols whereas structures can only conform to protocols.
- Classes are *reference types* whereas structures are *value types*. Semantically, a value type is a type whose value is **copied** when it‚Äôs assigned to a variable or constant, or when it‚Äôs passed to a function. This is also the reason why, in the example above for dot notation, we were able to assign an user instance to a `let` constant and still be able to change its stored value `email`. Because when reassigning `email`, the underlying **reference** in `user` hasn't changed. But if `User` is defined as a struct, `let user` would then be representing a value instead of a reference. Then changing the email would be considered mutating that value, which is not allowed for a constant. (Fun fact: I was actually asked about this during interview with Apple!)

## Optionals

*Optional* is a special type in Swift. It is used with another type and adds `nil` to the possible values of that type. In short, it handles the absence of a value. For example, an *optional String* means there's either a *String*, or there's no value at all. A regular, *non-optional* type cannot be `nil`.
```swift
var name: String? = nil
name = "üêª"
```
The process to retrieve the value from an optional is called **unwrapping**. In general, there are many ways of unwrapping an optional, but we will focus on three of the most common ones today.

### Force Unwrapping

Force unwrapping is the most straightforward way of unwrapping an optional. It is done by adding `!` to the end of a variable.
```swift
var name: String? = nil
name = "üêª"
var nameNonOptional: String = name!
```
However, force unwrapping will crash your code if the optional is `nil`. So in practice, you should force unwrap only when you're sure it's safe.

As a side note, it is possible to define optional values without having to unwrap them every time in order to use them. 
```swift
let name: String! = nil
name = "üêª"
```
This is called **implicitly unwrapped optional**. The optional values defined using this method behave as if they were already unwrapped. But if you try to use them when they are `nil`, your code will crash. This is commonly used for variables that start as `nil`, but will always have a value before you need to use it.

### Optional Binding

You use optional binding to find out whether an optional contains a value, and if so, to make that value available as a temporary constant or variable.

```swift
var name: String? = nil
name = "üêª"
if let nameNonOptional = name {
    print("The name is \(nameNonOptional)")
    // The name is üêª
} else {
    print("Name not available")
}
```

Multiple values can be binded in a single `if-let` statement. Each statement is separated using a comma. In the following example, *failable initializer* `Int(_:)` returns an optional integer `Int?`.

```swift
var startStr = "2", endStr = "10"
if let startDay = Int(startStr), let endDay = Int(endStr) {
    print("Span: \(endDay - startDay) days")
}
```

You can also use regular boolean expression in an `if-let`. For example, if we want to print only when the day difference is more than 0:

```swift
if let startDay = Int(startStr), let endDay = Int(endStr),
    endDay > startDay {
    print("Span: \(endDay - startDay) days")
}
```

### Early Exit

A `guard` statement behave very similarly to an `if` statement. It uses a boolean expression to determine whether to continue executing code in a function or transfer control to exit the code. In another word, `guard` checks for requirements in a specific line of code.

```swift
let calendar = NSCalendar.current
// Friday?
guard calendar.component(.weekday, from: Date()) == 6 else {
    return
}
print("Smash Bros üéÆ üéâ")
```

However, the reason why `guard` introduced here is because it's most commonly used with `let` to create conditional binding that's available in the same block scope, and it works pretty much the same as the `if-let` statement.

```swift
var startStr = "2", endStr = "10"
guard let startDay = Int(startStr), let endDay = Int(endStr),
    endDay > startDay else {
    return
}
print("Span: \(endDay - startDay) days")
```


