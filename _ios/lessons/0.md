---
layout: page
title: Lesson 0
page_order: 0
parent: Lessons
grand_parent: Overview
description: None
---

# Introduction to Swift and iOS Development
{: .no_toc }
*by Michael Lin*
## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

# Getting Started

Hello everyone and welcome to ŒúŒîŒí üéâüéâüéâ. First of all, congratulations on making it through the interview ü•≥! A bit about myself: my name is Michael, currently a sophomore studying CS and Econ. I love biking, playing badminton and I had been playing ice hockey for 5 years before coming to college. I cook almost everyday, mostly Chinese food but I do occasionally try to make other stuff too. I'm an international student from China so I speak native mandarin (which is also why there's probably gonna be lots of typos in what you are about to see: I had to run it through grammarly twice to make sure I don't make stupid mistakes). But anyway, I'm super excited to have you all this semester and I assure you it's gonna be great!

To start things off, I know the TOC looks scary but I promise you this is only gonna be the first week. iOS dev is awesome but it does come with a little bit of learning curve. Be patient and be sure to ask question! Also special thanks to our two wonderful mentors this semester: Ian and Janvi. They will be helping you guys through office hours, project parties, and during mentor meetups.

Without further ado, let's get started üö¢üö¢

## Install Xcode

If you haven't done it already, go to App Store and install the latest version of Xcode. The entire SDK would be around 30G, but it can get to 40G or even 60G after compiling some larger projects. So you might need to free up some space before doing that.

For the following Swift Tutorial, it might be helpful to try out some of the expressions yourself. In that case, you can use a Swift Playground. It's a place where you can conveniently run your Swift code and it's mainly used as an educational tool. To create a Swift Playground, you will first need to set up and launch Xcode. 
![Xcode Launch Screen](/assets/images/xcode-launch-screen.png "Xcode Launch Screen")
When you are on this screen, go to the top-left menu bar and select **File > New > Playground..** When Xcode asks you to choose a template, double click **Blank**. For the file location, my experience is you can keep it anywhere you like, but if you are using iCloud storage, do **NOT** put any Xcode files or projects in the folder that's using iCloud (generally that would mean Desktop and Documents). Especially when we start using Cocoapods, Xcode might start duplicating files if your local files are replaced with iCloud references.

# The Swift Programming Language

## Constants and Variables

In Swift, you declare a constant with the `let` keyword and variables with the `var` keyword.
``` swift
var foo = ‚ÄúHello‚Äù   /* Variable */
let bar = ‚ÄúWorld‚Äù   /* Constant */
```
You cannot reassign the value of a constant once it's declared.

You can specify the type of a variable or constant using `:`. This also allows you to declare a variable or constant without initializing it. However, it will not be usable until you give it a value (even `nil`).

``` swift
var name: String
name = ‚ÄúOski‚Äù
```

If you do not specify a type, Swift can infer it from the value it was initially assigned to. This is known as **type inference**.

Swift is a **strongly-typed** language. That means you can't reassign the value of a variable or constant to a different type once it's declared.

For naming, always stick to lowerCamelCase for constants and variables.

## Collection Types

Swift provides three primary collection types, known as arrays, sets, and dictionaries, for storing collections of values. Arrays are ordered collections of values. Sets are unordered collections of unique values. Dictionaries are unordered collections of key-value associations.

![Collections in Swift](https://docs.swift.org/swift-book/_images/CollectionTypes_intro_2x.png "Collections in Swift")

### Array

The type of a Swift array is written in full as `Array<Element>`, where Element is the type of values the array is allowed to store. You can also write the type of an array in shorthand form as `[Element]`. Therefore, an array can be declared
like this
```swift
var libraries: [String] = ["Moffitt", "Main Stack", "EAL"]
```
Retrieve or modify a value from the array by using a subscript.
```swift
var firstItem = libraries[0]
libraries[1] = "Music Library"
```
Append a new value by calling the `append(_:)` method
```swift
libraries.append("Engineering Library")
```
Alternatively, append an array of one or more compatible items with the addition assignment operator `+=`
```swift
libraries += ["Law Library", "Bancroft"]
```

### Dictionary

The type of a Swift dictionary is written in full as `Dictionary<Key, Value>`, where Key is the type of value that can be used as a dictionary key, and Value is the type of value that the dictionary stores for those keys. You can also write the type of a dictionary in shorthand form as `[Key: Value]`. Therefore, a dictionary can be declared like this
```swift
var distance: [String: Double] = ["Moffitt": 0.9, "Main Stack": 1.0, "EAL": 1.1]
print("The dictionary contains \(distance.count) items.")
// Prints "The dictionary contains 3 items."
```
Similar to arrays, you can retrieve or modify a value from the dictionary using subscript.
```swift
distance["Main Stack"] = 1.3
distance["Moffitt"]
```
However, there is no `append(_:)` method in dictionary. To add a new value, simply use the subscript.
```swift
distance["Music Library"] = 1.5
```

### Set

The type of a Swift set is written as Set<Element>, where Element is the type that the set is allowed to store. Sets do not have an equivalent shorthand form. A set can be created with an array literal.

```swift
var libraries: Set<String> = ["Moffitt", "Main Stack", "EAL"]
```

You can insert an element by calling the set's `insert(_:)` method. To check whether a set contains a particular item, use the `contains(_:)` method.

## Control Flow

### If Statement

In swift, a basic `if` statement looks like this
``` swift
if condition {
    action
}
```
You can chain multiple `if` statement together using `else if` and `else`
```swift
if condition {
    statements
} else if {
    statements
} else {
    statements
}
```
You can combine multiple predicates using the logical operator `!` `||` `&&`.
For single-expression if statements, you can usually simplify them with the
**ternary operator**
```swift
condition ? expression : expression
```
If the condition is true, the first expression will be executed and its return
value would be the return value of the whole statement. A simple example can
look like this
```swift
var feel: String = temp > 75 : "hot" : "ok" 
```

### For-In Loops

You use the `for-in` loop to iterate over a sequence, such as items in an array, ranges of numbers, or characters in a string.
```swift
let names: [String] = ["Anna", "Alex", "Brian", "Jack"]
for name in names {
    print("Hello, \(name)!")
}
```
You can also use `in` to iterate through a dictionary. That would give you
all of its key-value pairs.
```swift
let numberOfLegs: [String: Int] = ["spider": 8, "ant": 6, "cat": 4]
for (animalName, legCount) in numberOfLegs {
    print("\(animalName)s have \(legCount) legs")
}
```

### While Loops

A `while` loop starts by evaluating a single condition. If the condition is `true`, a set of statements is repeated until the condition becomes `false`.
```swift
while condition {
    statements
}
```

## Functions

Every function is a chunk of code that performs a specific task. It is defined using the keyword `func` followed by the name of the function. Optionally, you can define one or more parameters to be passed in as input. You can also specify the return type using `->`. For example, a simple function declaration can look like this.

```swift
func answer(question: String) -> String { }
```

You would then call the function using its name and parameter, which will return a `String`.

```swift
var answer1: String = answer(question: "Question 1")
```

For each parameter, you can also specify its *label*, and it will be used when you are **calling** the function. This helps to create easier to read function calls like this.

```swift
func answer(for question: String) -> String { }

var answer1: String = answer(for: "Question 1")
```

By default, the *argument labels* are the same as the *parameter names*, and will be used when calling the function like in `answer(question: "Question 1")`. If you want no function label at all during the function call, write an underscore `_` for that parameter.

```swift
func answer(_ question: String) -> String { }

var answer1: String = answer("Question 1")
```

## Classes

If you are new to the OOP (Object-Oriented Programming) model, there are many ways of describing classes. But here is my favorite: Think of it as a blueprint for a house. You can create multiple instances of that house with the same blueprint, but the interior design which is the data is going to be different. Each house operates on its own, but they all share the same structure and behaviors. 

In Swift, classes are declared using the `class` keyword. You define properties and methods to add functionality to your classes using the same syntax you use to define constants, variables, and functions.

```swift
class User {
    var username: String = ""
    var email: String = ""

    func printEmail() {
        print(email)
    }
}
```

A class can *inherit* methods, properties, and other characteristics from another class. When one class inherits from another, the inheriting class is known as a *subclass*, and the class it inherits from is known as its *superclass*.

```swift
class Admin: User {
    managedUsers: [User] = []
}
```

The value assigned with property declarations are the **default values** that will be assigned during class initialization. If no default value is specified, a custom initializer is needed.

```swift
class Admin: User {
    managedUsers: [User]

    init(withManagedUsers users: [User]) {
        self.managedUsers = users
        super.init()
    }
}
```
Members of an class (either a property or a method) can be accessed using the dot notation `.`.
```swift
let user = User()
let user.email = "example@domain.com"
```

## Structs

In Swift, structures and classes have very similar functionalities. Both of them can define properties and methods, conform to protocols, and be extended using an extension (we will talk about the last two in the next lesson).
```swift
struct Event {
    var eventName: String
    var startTime: Date
    var endTime: Date

    // Initializer
}
```

However, there are a few key differences too:
- Classes can inherit from another class and/or conform to one or more protocols whereas structures can only conform to protocols.
- Classes are *reference types* whereas structures are *value types*. Semantically, a value type is a type whose value is **copied** when it‚Äôs assigned to a variable or constant, or when it‚Äôs passed to a function. This is also the reason why, in the example above for dot notation, we were able to assign an user instance to a `let` constant and still be able to change its stored value `email`. Because when reassigning `email`, the underlying **reference** in `user` hasn't changed. But if `User` is defined as a struct, `let user` would then be representing a value instead of a reference. Then changing the email would be considered mutating that value, which is not allowed for a constant. (Fun fact: I was actually asked about this during interview with Apple!)

## Optionals

*Optional* is a special type in Swift. It is used with another type and adds `nil` to the possible values of that type. In short, it handles the absence of a value. For example, an *optional String* means there's either a *String*, or there's no value at all. A regular, *non-optional* type cannot be `nil`.
```swift
var name: String? = nil
name = "üêª"
```
The process to retrieve the value from an optional is called **unwrapping**. In general, there are many ways of unwrapping an optional, but we will focus on three of the most common ones today.

### Force Unwrapping

Force unwrapping is the most straightforward way of unwrapping an optional. It is done by adding `!` to the end of a variable.
```swift
var name: String? = nil
name = "üêª"
var nameNonOptional: String = name!
```
However, force unwrapping will crash your code if the optional is `nil`. So in practice, you should force unwrap only when you're sure it's safe.

As a side note, it is possible to define optional values without having to unwrap them every time in order to use them. 
```swift
let name: String! = nil
name = "üêª"
```
This is called **implicitly unwrapped optional**. The optional values defined using this method behave as if they were already unwrapped. But if you try to use them when they are `nil`, your code will crash. This is commonly used for variables that start as `nil`, but will always have a value before you need to use it.

### Optional Binding

You use optional binding to find out whether an optional contains a value, and if so, to make that value available as a temporary constant or variable.

```swift
var name: String? = nil
name = "üêª"
if let nameNonOptional = name {
    print("The name is \(nameNonOptional)")
    // The name is üêª
} else {
    print("Name not available")
}
```

Multiple values can be binded in a single `if-let` statement. Each statement is separated using a comma. In the following example, *failable initializer* `Int(_:)` returns an optional integer `Int?`.

```swift
var startStr = "2", endStr = "10"
if let startDay = Int(startStr), let endDay = Int(endStr) {
    print("Span: \(endDay - startDay) days")
}
```

You can also use regular boolean expression in an `if-let`. For example, if we want to print only when the day difference is more than 0:

```swift
if let startDay = Int(startStr), let endDay = Int(endStr),
    endDay > startDay {
    print("Span: \(endDay - startDay) days")
}
```

### Early Exit

A `guard` statement behave very similarly to an `if` statement. It uses a boolean expression to determine whether to continue executing code in a function or transfer control to exit the code. In another word, `guard` checks for requirements in a specific line of code.

```swift
let calendar = NSCalendar.current
// Friday?
guard calendar.component(.weekday, from: Date()) == 6 else {
    return
}
print("Smash Bros üéÆ üéâ")
```

However, the reason why `guard` introduced here is because it's most commonly used with `let` to create conditional binding that's available in the same block scope, and it works pretty much the same as the `if-let` statement.

```swift
var startStr = "2", endStr = "10"
guard let startDay = Int(startStr), let endDay = Int(endStr),
    endDay > startDay else {
    return
}
print("Span: \(endDay - startDay) days")
```

# Introduction to iOS Development

## Create Your First Xcode Project

While I've mentioned earlier that Swift Playground is good for trying out code and ideas, an Xcode project is where the real developing begins. Although you won't need to create your own project for MP1, you should always know how to create one. This short video takes you step by step through the process.
<div style="width: 560px; margin: auto;">
<iframe width="560" height="315" src="https://www.youtube.com/embed/ZGUPA-R_4Mk" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

## Xcode Interface

Once you've created the project, take a moment to familarize yourself with the interface. There's a lot of information on screen, so this video is going to break it down to help you understand.
<div style="width: 560px; margin: auto;">
<iframe width="560" height="315" src="https://www.youtube.com/embed/ykl73HPcLco" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

## Basic File Structure and Management

As we are getting used to the interface, let's take a look at the basic file structure that comes with the default app template and how xcode manages them.
<div style="width: 560px; margin: auto;">
<iframe width="560" height="315" src="https://www.youtube.com/embed/Q-Hr8hSbS1I" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

## View Controllers and Views

The first main concept we are going to introduce here is the *view controller*. View controllers are the foundation of your app. Every app has at least one view controller, and most apps have several. It manages components of your app's interface called *views* as well as the interactions between that interface and the underlying data.

View controllers are like screens. For example, when switching between tabs, you are switching between different view controllers. So in essence, They are the building blocks of your app's navigation.

You create your custom view controller through *subclassing* the build-in `UIViewController` class from the `UIKit` framework. In the following example, we declare a a view controller called `HomeViewController` and set its backgroundColor to red.

```swift
import UIKit

class HomeViewController: UIViewController {

    override func viewDidLoad() {
        super.viewDidLoad()
        view.backgroundColor = UIColor.systemRed
    }
}
```

Custom view controllers are usually named `XXXViewController` or `XXXVC` for short. Just like any other type in Swift, you should always use **UpperCamelCase** when naming view controllers. There should be only one view controller in each file, and the name of the file should be `View Controller's Name.swift`.

### View Management

The most important role of a view controller is to manage a hierarchy of views. Every view controller has a single root view that encloses all of the view controller‚Äôs content. To that root view, you add the subviews you need to display your content. The parent view of a subview is also called the *superview*.

<img src="https://developer.apple.com/library/archive/featuredarticles/ViewControllerPGforiPhoneOS/Art/VCPG_ControllerHierarchy_fig_1-1_2x.png"
    alt="View Controller View Hierarchy"
    style="width: 442px; display: block; margin: auto;" />

You access a view controller's root view through the `self.view` property (or just `view` where `self` pointer can be omitted). All view components in `UIKit` are subclasses of the `UIView` class, which defines the behaviors that are common to all views. You can add subview to any view using the `addSubview(_:)` method.

### Life Cycle

A view controller comes with a set of methods that manage its view hierarchy. iOS automatically calls these methods at appropriate times when a view controller transitions between states. These transitions are known as the *Life Cycle Events*. When you create a view controller subclass, it inherits the methods defined in UIViewController and lets you add your own custom behavior for each method.

One method you've seen so far is `viewDidLoad()`. It's called *after* the views in a view controller are created and loaded into memory. Since this usually only happens once in the view controller's entire lifecycle, `viewDidLoad()` is commonly used for styling, adding subviews, and creating and activating constraints.

Other life cycle methods such as `viewDidAppear()`, `viewWillAppear()`, `viewWillDisappear()` and etc., can be called multiple times depending on how the view controller behaves.

<img src="https://developer.apple.com/library/archive/referencelibrary/GettingStarted/DevelopiOSAppsSwift/Art/WWVC_vclife_2x.png"
    alt="View Controller Lifecycle"
    style="width: 442px; display: block; margin: auto;" />

You define the custom behaviors for a lifecycle event through overriding the default implementation of the corresponding lifecycle method. 

```swift
override func viewDidLoad() {
    super.viewDidLoad()
    view.backgroundColor = UIColor.systemRed
}
```
Note: Although superclass implementation in `super.viewDidLoad()` doesn't do anything, it's a good habit to call super for all functions you override that don't have a return value.

## First Custom View

As you've learned in the previous section, the build-in `viewDidLoad()` is useful for many one-time setup including styling and adding subviews. However, although it is possible to create, style, and add subview entirely using `viewDidLoad()`, it is not recommanded for many reasons:

- Add your UI grows more complex, the `viewDidLoad()` function tends to get very bloated, which is bad for readability.
- If you want to keep a reference of the views created, you'd have to declare an optional instance variable which initializes to `nil`, then fill in the value in `viewDidLoad()`.

Therefore, it is common to defer some of that setup to the initialization phase before `viewDidLoad()` kicks in. Conveniently, Swift allows us to initialize a variable along with the declaration using a *closure*, which is kinda like the lambda expression in Python. Recall that in Python we can wrote tiny, "anonymous" function like this

```python
lambda x, y: x * y
```

and in Swift, the equivalent closure can look like this

```swift
{ x, y in
    return x * y
}
```
We will formally introduce closure in our next lesson, but for now let's just stick to the notion that it's just a portable function that can be called and passed around.

In this video, we will see how to use this pattern to create a `UILabel` and add it to the rootview.

<div style="width: 560px; margin: auto;">
<iframe width="560" height="315" src="https://www.youtube.com/embed/RN1_SkkarFc" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

### Frames

In the last video we used something called `frame` to create our `UILabel`, and you probably already have a little idea what that's for. 
```swift
UILabel(frame: CGRect(x: 0, y: 88, width: UIScreen.main.bounds.width, height: 60))
```
In UIKit, the position of a view is described by a point-based coordinate system. It starts from the top left of the referencing view (0, 0) and ends at bottom right. A frame is a rectangle defines the size and position of the view in its superview‚Äôs coordinate system.

<img src="https://iosimage.s3.amazonaws.com/2018/5-frame-vs-autolayout/coordinatesystem.png"
    alt="Coordinate System in UIKit"
    style="width: 300px; display: block; margin: auto;" />

One thing to keep in mind is that for `UILabel`, changing the frame will not affect the physical size of the label, unless the frame causes it to overflow. This is because the frame only specifies a rectangle to which we put our view in. The size of the label itself is controlled by its font size, which was set through `UILabel.font` and was 27 points in our last example. However, if we set the backgound color to something we will be able to see, resizing the frame does change the way it looks.

