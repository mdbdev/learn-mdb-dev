---
layout: page
title: Lesson 5
page_order: 5
parent: Lessons
grand_parent: Overview - iOS
description: Local Data Persistence and App's Life Cycle
---
# Local Data Persistence and App's Life Cycle
{: .no_toc }
*Michael Lin*

## Table of Contents
{: .no_toc .text-delta }

1. TOC
{:toc}

# Local Data Persistence

A few weeks ago we talked about Cloud Firestore, an NoSQL cloud database that can store and sync data from your app, and we used it in MP3 to create an social App where you can create and share event details amongst other user. But that's a big jump - not always we would want to store our data in a remote server. In some use cases, storing your data locally is much more efficient and less error-prone. 

A classic example of where you would want to use local data storage is user's settings. Assuming that you don't care about syncing user settings between different devices, there's no point of uploading them to a remote server. Another example could be when the data is too large to store on a server such as a movies or a bunch of photos, in which case you have no choice but to keep them locally.

## File Manager

The first local storage option that we will look at today is the *file system*. Just as most desktop OS, in iOS files are organized into many directories. In MP2, we used a `pokemon.json` file from our app's bundle folder to generate an array of `Pokemon` objects.

```swift
guard let url = Bundle.main.url(forResource: "pokemons", 
                                withExtension: "json") else { ... }

guard let jsonData = try? Data(contentsOf: url) as Data else { ... }
```

When Xcode builds the app, it creates a `bundle` object that contains all the binaries, resources, and extra files in the project. It organizes your ap p into a well-defined package, so that when people download it from the App Store, they only need to download the (main) bundle into their file system. And as you saw in MP2, with bundles, we can access its content without knowing the structure of the bundle, which makes it great for static resource files like images and our `pokemon.json`.

<img src="/assets/images/copy-bundle-resource.png"
    alt="Bundle resource"
    style="width: 100%; display: block; margin: auto;" />

However, bundles are *read only* and are deleted with the app. Therefore, if you are looking to write back to the file system, you will have to interact with other os directories.

Luckily, it turns out that is also simple, you just have to use the `FileManager` class.

```swift
guard let url = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)
    .first!.appendingPathComponent("pokemon.json") else { ... }

guard let jsonData = try? Data(contentsOf: url) else { ... }
```

This reads the `pokemon.json` from the document directory under the user domain (`~`).

Writing to the url is even more straightforward:

```swift
try jsonData.write(to: url)
// Error handling
```

See, no opening and closing file or managing buffer. That's why I love Swift.

## User Defaults

Being able to manage files is great, but sometimes, it can be an overkill too. What if you just want to store a few app settings or flags (like whether it's the app's first launch).

This is where [`UserDefaults`](https://developer.apple.com/documentation/foundation/userdefaults) comes to the rescue. It gives you the ability to store key-value pairs to the user's internal database. For example, you can store the default layout for your Pokemon collection view like this

```swift
UserDefaults.standard.set("grid", forKey: "pokemonLayout")
```

and to get the value:

```swift
let layoutRaw = NSUserDefaults.standard.string(forKey: "pokemonLayout") ?? "row"
let layout = PokemonLayout(rawValue: layoutRaw)
```

Notice that the getter returns an optional string, so we can use the nil-coalescing operator `??` to provide a default value.

Behind the scene, your data is persisted through a `.plist` file in the app's package. This means that User Defaults can only store `NSData`, `NSString`, `NSNumber`, `NSDate`, `NSArray`,`NSDictionary`, or their Swift counterparts, because these are the types allowed in a property list. Though you can typically store other types by converting them into an instance of `NSData`.

# App's Life Cycle

In this section we will bring our attention to the two files that we've been kind of ignoring so far: `AppDelegate` and `SceneDelegate`. These are the files that are responsible for responding to the transition events between *states* of the app, known as *life cycles*.

<img src="/assets/images/app-delegate.png"
    alt="App Delegate in iOS"
    style="width: 100%; display: block; margin: auto;" />

At a high level, these are just like delegate objects, telling you what's happening with your app. But in practice, there're a lot more details than you would expect. While we are not going to get into too much of that, it is important that you learn the basics as it will give you a much better picture of what's going on behind the curtain.

<img src="https://docs-assets.developer.apple.com/published/c63cd35863/4d403429-fa30-4706-863f-5e3617ee21d0.png"
    alt="Managing your App's Life Cycle"
    style="width: 70%; display: block; margin: auto;" />

## Background

Before iOS 12, each app can only have one instance running on foreground at any given time. So UIKit delivers all life-cycle events to the `UIApplicationDelegate` object in `AppDelegate.swift`. It works with `UIApplication` and you can think of it as the "root" of the App. Previously, the app delegate would have access to a `UIWindow` object where the app's root view controller will reside. But on iOS 12 Apple added a new feature that allows multiple instances of your app's UI simultaneously.

<img src="https://docs-assets.developer.apple.com/published/8ce996907a/fc0975ae-c186-438c-abdd-5280f650c377.png"
    alt="App Delegate in iOS"
    style="width: 80%; display: block; margin: auto;" />

This means that an app may have to manage more than one life cycles and windows at the same time, which is why after iOS 12, we have a new concept called `scene`. A scene manages an instance of your app's UI and its life cycle just as the app delegate did before. In other words, We still only have one "app", but now we can have multiple "scenes" running under that app.

## Using Life Cycle Methods

Despite the convoluted system of scenes and life cycle events, using the life cycle methods itself is pretty straightforward. Just put the code that you want to execute in the life cycle functions, and it will be triggered when the corresponding events occur. One that we've already used is the `scene(_:willConnectTo:options:)` method. We implemented a simple check in MP3 to see if an user has already logged in.

```swift
class SceneDelegate: UIResponder, UIWindowSceneDelegate {

    var window: UIWindow?

    func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {

        guard let windowScene = (scene as? UIWindowScene) else { return }
        window = UIWindow(frame: UIScreen.main.bounds)
        window?.windowScene = windowScene
        if FIRAuthProvider.shared.isSignedIn() {
            let vc = UIStoryboard(name: "Main", bundle: nil).instantiateInitialViewController()
            window?.rootViewController = vc
        } else {
            let vc = UIStoryboard(name: "Auth", bundle: nil).instantiateInitialViewController()
            window?.rootViewController = vc
        }
        window?.makeKeyAndVisible()
    }

    /* ... */
}
```
