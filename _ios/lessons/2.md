---
layout: page
title: Lesson 2
page_order: 2
parent: Lessons
grand_parent: Overview
description: Concurrency & Multithreading":" GCD, ARC 
---

# Concurrency & Multithreading: GCD, ARC 
{: .no_toc }

## Table of Contents
{: .no_toc .text-delta }

1. TOC
{:toc}

# Initialization

*Initialization* is the process of preparing an instance of a class, struct, or enum for use. This is the reason why previously we mentioned that we don't have access to `self` inside the closure initialization of our UI components - because it hasn't been *prepared* yet. In this section we will discuss some important details of initialization in Swift.

## Initializers in Value Type

Initialization in value type is usually simpler than its counterpart due to the lack of inheritance. Suppose we have a `struct` called `Course`
```swift
struct Course {
    var name: String
    var code: String
}
```
An initializer is essentially a function denoted by the keyword `init`. In our case, it can look like this.
```swift
struct Course {
    var name: String
    var code: String

    init(name: String, code: String) {
        self.name = name
        self.code = code
    }
}
```

To make a new instance of `Course`, you simply call

```swift
let course = Course(
    name: "Introduction to Sophomore Mathematic Maturity",
    code: "CS 70"
)
```

The first important rule: an initializer must initialize **all** of its stored properties.

That is unless, the property has a default value or is an optional. For example, the following code is also valid.
```swift
struct Course {
    var name: String
    var code: String = "CS 70"

    init(name: String) {
        self.name = name
    }
}
```

## Initializers in Reference Type

Initialization for reference type (a.k.a class), however, is much more complex. The most obvious issue is, with the addition of class inheritance, we should no longer have a single initializer that initializes every property of that class, as some of them might be defined in its superclass, thus the *superclass* should be in charge of that part of the initialization. This is known as *initializer delegation*. To achieve this, Swift introduces two types of initializers for class type: *designated initializers* and *convenience initializers*.

### Designated and Convenience Initializers